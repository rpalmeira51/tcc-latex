\chapter{The Algorithmic Approach}\label{chap:alg-approach}

In this chapter we explore structures and algorithms that encapsulate a brute force process of finding \((h,h')\)-modified homomorphisms from \(G\) to \(CH\) 
with improved costs over $h$.
We, also, show that positive results of the presented algorithms proves Conjecture~\ref{conj:main-conjecture} and present a simple complexity analysis. 
We use a python inspired pseudocode to specify the algorithms for ease of reading (and also because we implemented a checker in SageMath see Chapter~\ref{chap:4}).

\section{Configurations}\label{sec:configurations}

Given a tree $T$, a \emph{configuration} of \(T\) is any function $conf\colon L(T) \to V(\ch)$.
We say that a configuration $conf$ of \(T\) is \emph{feasible} if there is a homomorphism $h \colon T \to CH$ such that \(h|_{L(T)} = conf\), i.e., such that $conf(x) = h(x)$ for every $x \in L(T)$. In other words, $conf$ is feasible if it can be \emph{completed} to a homomorphism $h\colon T \to CH$.
In this case, we say that \(h\) is a \emph{completion} of \(conf\).
Note that there may be many different completions of \(conf\).
We denote by \(RH(conf)\) the set of completions of \(conf\), 
and we say that any two homomorphisms in \(RH(conf)\) are \emph{related}.
Observe that two homomorphisms \(h_1,h_2 \colon T \to \ch\) 
are related if and only if \(h_1|_{L(T)} = h_2|_{L(T)}\).

\begin{definition}\label{def:conf-costs}
Given a configuration \(conf\), 
the \emph{free cost} $FC(conf)$ and the \emph{restricted cost} $RC(conf)$ of \(conf\) 
are, respectively, the values:
\begin{align*}
    FC(conf) & = \min\{ cost(h) : {h \in RH(conf)}\}, \text{ and } \\
    RC(conf) & = \min\{ cost(h) : {h \in RH(conf) \text{ and } h(r) \in B_1}  \}.
\end{align*}
%
In the case that there is no completion \(h\) of conf such that \(h(r) \in B_1\), 
we set \(RC(conf) = \infty\) and, more generally, if there is no completion for any root color $FC(conf) = RC(conf) = \infty$ and the configuration is unfeasible.
\end{definition}

The later case of Definition~\ref{def:conf-costs}, 
where there is no completion of~\(h\), is crucial in the case \(T\) has height \(0\).
Indeed, in this case, \(conf\) consists precisely of the color of~\(r\), 
and there is only one completion of \(conf\) which is \(conf\) itself.
Therefore, if \(conf(r) \in B_1\), then \(FC(conf) = RC(conf) = 1\);
and if \(conf(r) \notin B_1\), then we have \(FC(conf) = 0\)
while \(RC(conf) = \infty\) because the set \(\{h : h \in RH(conf)\text{ and } h(r) \in B_1)\}\) is empty.

Observe that \(FC(conf) \leq RC(conf)\) for every configuration conf of a tree~\(T\).
We say that a configuration \emph{\(conf\) is bad} if equality holds, 
i.e., if \(FC(conf) = RC(conf)\);
and we say that a configuration \emph{$conf$ is good}, otherwise, i.e., if $FC(conf) < RC(conf)$.

The next lemma is a straightforward consequence of the definition above.

\begin{lemma}\label{lemma:every-good-configuration}
    Let \(G\) be a graph with girth $g$,
    $T$ be a cubic tree in $G$ of size $\ell < g$ rooted in \(r\),
    $h \colon G \to CH$ be a homomorphism with $h(r) \in B_1$
    and \(conf = h|_{L(T)}\).
    If $conf$ is good, then there is an $h$-compatible homomorphism $h'\colon T \to CH$ such that $cost(h') < cost(h|_{T})$.
\end{lemma}

Naturally, it follows that, if all feasible configuration of a given tree $T$ of height $\ell$ are good, 
we verify Conjecture~\ref{conj:main-conjecture} for any graph $G$ with girth larger than $\ell$.
For example,
if we have an algorithm that is able to calculate the free and restricted costs of configurations, 
we are able to computationally determine the bad configurations on a cubic tree of any level 
and, if we find a positive integer for $\ell$ for which there are none, we prove Conjecture~\ref{conj:main-conjecture}.

Algorithm~\ref{alg:naive-bottom-up} (\texttt{GenerateBadConfs}) relying 
on the aforementioned algorithm for calculating costs (\texttt{CalculateCosts}) defines this process in pseudocode.
In our pseudocode implementations, we choose to represent configurations as vectors of colors (integers from 0 to 15)
ordered according to their corresponding leafs which are ordered from left to right
(the orderings of the leafs are discussed more deeply in Section~\ref{sec:signatures}), 
but the representation works for any simple numerical labeling of tree leafs.
We produce all configurations on the tree by iterating over all $|L(T)|^{16}$ possible colorings of the leafs and than check the costs to verify 
if a given configuration is good, bad or unfeasible.

\begin{algorithm}[H]
\caption{Returns all bad configurations on a given tree $T$}\label{alg:naive-bottom-up}
\footnotesize
\begin{minted}[xleftmargin=\parindent,linenos,escapeinside=||,mathescape=true]{python}
def GenerateBadConfs(T):
    bads = []
    for conf in product(list(range(0,16)), repeat = len(L(T))):
        fc, rc = CalculateCosts(T, conf)
        if(fc != |$\infty$| and fc == rc): 
            # fc != |$\infty$| means that conf is feasible
            # fc == rc means that conf is bad
            bads.Append(conf)
    return bads 
\end{minted}
\end{algorithm}

\newcommand{\parents}{\mathcal{P}}
The need to computationally calculate the free and restricted costs motivates the following.
Recall that \(T^{(1)} = T \setminus L(T) \), now,
let $conf$ be a configuration of $T$, 
a \emph{parents configuration} of \(conf\)
is any configuration $conf^p$ of \(T^{(1)}\)
for which there is a completion $h$ of \(conf\) with $h(L(T^{(1)})) = conf^p$. 
In this case, we additionally say that $conf$ is a \emph{child} of $conf^p$.
The set of parents configurations of \(conf\) is denoted by \(\parents(conf)\).

Algorithm~\ref{alg:naive-bottom-up:parents} (ParentsConfigurations) 
generates the parents configurations of any configuration $conf$ of a tree $T$ as follows.
First, note that each parents configuration is a configuration of \(L(T^{(1)})\)
in which each leaf \(\texttt{l}\) in \(L(T^{(1)})\) has a color adjacent to the colors of its children, 
i.e., \(\texttt{l}\) must receive a color that is in the intersection of the neighborhoods (in $\ch$)
of the colors of its children.
This results in a set of possible colors that each vertex in $L(T^{(1)})$ can be colored with. 
Then the Cartesian product\footnote{In Python the Cartesian product can be performed using the function \texttt{product} of the library \texttt{itertools}~\cite{itertools}} of these possible colors contains the set of all parents configurations of $conf$ (see Algorithm~\ref{alg:naive-bottom-up:parents}).
Note that some of those configurations may be unfeasible as it is possible to choose colors for sibling vertices in $T^{(1)}$ such that the resulting configuration cannot be completed.
The parents configurations of \(conf\)
are precisely the feasible configurations in the Cartesian product of the possible colors.
The following lemma comes naturally.
%TODO Verificar pontos finais: todo parágrafo, e toda equação centralizada tem que ser pontuada.
\begin{lemma}\label{lemma:child-costs} 
    Let $T$ be a complete tree with root \(r\), and $conf$ a configuration of~$T$.
    If \(T\) has height $l\geq 1$, then the following hold.
    \begin{itemize}
    \item[] \(FC(conf) = cost(conf) + \min\{FC(conf^p) : conf^p \in \parents(conf)\} \); and 
    \item[] \(RC(conf) = cost(conf) + \min\{RC(conf^p) : conf^p \in \parents(conf)\}\).
    \end{itemize}
    Consequently, a configuration \(conf\) is bad if and only if
    \begin{align*}
        & cost(conf) + \min\{FC(conf^p) : conf^p \in \parents(conf)\}\\
        &= cost(conf) + \min\{RC(conf^p) : conf^p \in \parents(conf)\},\\
        &  \min\{FC(conf^p) : conf^p \in \parents(conf)\}\\
        &= \min\{RC(conf^p) : conf^p \in \parents(conf)\}.
    \end{align*}
\end{lemma}

\begin{algorithm}[H]
\caption{Returns iterator over parents configurations}\label{alg:naive-bottom-up:parents}
\footnotesize
\begin{minted}[xleftmargin=\parindent,linenos,escapeinside=||,mathescape=true]{python}
def ParentsConfigurations(T, conf):
    if len(conf) == 1:
        return []
    choices = []
    for l in L(|$T^{(1)}$|):
        children    = Children(l)
        choices_l   = |$\bigcap_{i \in children} N_{CH}(conf [i] )$|
        if(len(choices_l) == 0): #guarantees earlier that conf is unfeasible
            return []   
        choices.append(choices_l) 
    return product(choices)
\end{minted}
\end{algorithm}

Therefore, if all parents configurations of  \(conf\) are good, 
then \(conf\) is good and, 
consequently, any bad configuration of a tree of height at least 1 has at least one bad parents configuration.

\phantomsection
\refstepcounter{algorithm}
\label{alg:naive-bottom-up:costs}

We are now able to introduce Algorithm~\ref{alg:naive-bottom-up:costs} (\textttt{CalculateCosts}) which calculate the costs of any configuration \(conf\) using a ``bottom-up'' recursive algorithm that 
computes the free and restricted costs using the costs of each parents configuration of \(conf\)(See Lemma~\ref{lemma:child-costs}).
The case where there a no parents configurations, i.e $conf$ is a coloring over the root or unfeasible, calculating the costs is trivial and follows directly from Definition~\ref{def:conf-costs}.

\begin{algorithm}[H]
\caption{A simple algorithm for calculating costs using a ``bottom-up'' strategy}\label{alg:naive-bottom-up:costs}
\footnotesize
\begin{minted}[xleftmargin=\parindent,linenos, breaklines, escapeinside=||,mathescape=true]{python}
def CalculateCosts(T, conf):
    if len(conf) == 1:
        if(conf[0] in |$B_1$|):
            return 1,1
        else:
            return 0, |$\infty$|
    #respectively the min parent free cost and the min parent restricted cost
    minpfc, minprc = |$\infty$|, |$\infty$| 
    levelcost    = sum([1 for x in conf if x in |$B_1$|])
    for confp in ParentsConfigurations(T,conf):
        pfc, prc  = CalculateCosts(|$T^{(1)}$|, confp)
        minpfc, minprc = min(minpfc, pfc), min(minprc, prc)
    return minpfc + levelcost, minprc + levelcost
\end{minted}
\end{algorithm}


\section{Replacements}\label{sec:replacements}

Suppose we computed all bad configurations on a given tree $T$ of height $\ell$ and found out it is a non empty-set,
computing the bad configurations of a tree of height $\ell + 1 $ is prohibitively time-consuming
and, for each bad configuration of $T$, there is at least 
one good configuration which colors just a few vertices differently.
This motivates the search for 
a process that, using local operations, is able to modify, while avoiding increasing costs, configurations in order to change the coloring of certain vertices.
For this, we define \emph{replacements} as follows, in order to deal with the simple case of changing the color of a single vertex.

Let \(T\) be a complete \emph{binary} tree rooted in a vertex \(r \in V(T)\), 
let \(c_0 \in V(\ch)\) be a color and \(C\subseteq V(\chone) \setminus \{c_0\} \) a set of \emph{target} colors.
We call the pair $(c_0, C)$ a \emph{replacement with respect to \(T\)} if for every homomorphism $h \colon T \to CH$ with $h(r) = c_0$, there is a homomorphism $h_r$ such that:
(i)~$h_r(r) \in C$; 
(ii)~$h_r(L(T)) = h(L(T))$; and
(iii)~$cost(h_r) \leq cost(h)$.

The following lemma comes naturally.
\begin{lemma}\label{lemma:replacements-monotonicity}
    Let $T$ be a complete binary tree of height $\ell$ and $(c_0,~C)$ a replacement with respect to $T$. 
    Then~$(c_0,~C)$~is~a~replacement~for~any~complete~binary~tree~with~height~at~least~$\ell$.
\end{lemma}

As an example we present a simple family of replacements.
Let \(c_0\) be a color in $B_1$
and \(C\) be the set $(V(\ch) \setminus N_{\ch}(c_0)) \setminus \{c_0\}$, 
we say that $(c_0, C)$ is a \emph{trivial replacement} (see table \ref{table:replacements-height-1}).
The following proposition arises.

\begin{proposition}
    Every trivial replacement is a replacement with respect to the binary tree with~height~1.
\end{proposition}
\begin{proof}
Let \((c_0,C)\) be a trivial replacement.
We prove that \((c_0,C)\) is a replacement with respect to the complete binary tree \(T\) of height \(1\).
Indeed, let \(r\) be the root of \(T\) and \(l_1,l_2\) be its leaves, 
$c_0 \in \chone$ 
and \(h \colon T \to \ch\) with \(h(r) = c_0\).
Since \(c_0 \in N(h(l_1)) \cap N(h(l_2))\), 
by Fact~\ref{fact:common_neighbors}, 
we have \(|N(h(l_1)) \cap N(h(l_2))| \in \{2,5\}\).
Now, let \(c_1 \in N(h(l_1)) \cap N(h(l_2))\) with \(c_1\neq c_0\).
Since \(\ch\) has no triangles, \(c_1\) is not adjacent to \(c_0\), 
and hence \(c_1\in C\).
Finally, let \(h_r \colon T \to \ch\) be
the homomorphism with \(h_r(r) = c_1\), and \(h_r(l_i) = h(l_i)\) for \(i \in \{1,2\}\).
By the choice of \(c_0\), we have that $cost(c_0) \leq cost(c_1)$
and hence \(\cost(h_r) \leq \cost(h)\), 
as desired.
\end{proof}

\begin{table}
\centering
\caption{ TODO: FAZER UTILIZANDO C0 CERTOS PARA B1 Trivial Replacements} %explicar no caption quem é c_0 e C
\label{table:replacements-height-1}
\begin{tabular}{|c|c|}
% \hline
% \multicolumn{3}{| c |}{}\\
\hline
$c_0$ & C \\
\hline
0 &  \{2, 3, 4, 5, 7, 9, 11, 12, 14, 15\}  \\
\hline
1 & \{2, 5, 6, 7, 8, 10, 11, 12, 13, 14\}  \\
\hline
6 &  \{1, 2, 4, 5, 8, 9, 10, 11, 13, 15\}  \\
\hline
8 & \{1, 3, 4, 6, 7, 10, 11, 12, 13, 15\}  \\
\hline
10 &  \{1, 3, 5, 6, 8, 9, 12, 13, 14, 15\}  \\
\hline
13 &  \{1, 2, 3, 4, 6, 7, 8, 9, 10, 14\}  \\
\hline
\end{tabular}
\end{table}

The next lemma follows directly from the definition.
\begin{lemma}\label{lemma:replacements-subseteq}
    Let $T$ be a complete binary tree of height $\ell$ and $(c_0,~C)$ a replacement with respect to $T$. 
    Then any pair $(c_0, C_i)$ where $C \subseteq C_i$ and $ C_i \subseteq V(\chone)$ is a replacement.
\end{lemma}

This enable us to introduce \emph{minimal replacements}.
\begin{definition}\label{def:minimal-replacements}
    Let $T$ be a complete binary tree of height $\ell$ and $(c_0,~C)$ a replacement with respect to $T$. 
    We call $(c_0,~C)$ a \emph{minimal replacement} 
    if there is no replacement $(c_0,~C_i)$ in respect to $T$ such that $C_i \subset C$.
\end{definition}

Note that we are able to determine if a pair $(c_0, C)$ is a replacement for a given complete binary tree $T$ computationally
by verifying that every homomorphism $h$ that completes a configuration of $T$ such that $h(r)= c_0$ is related to a homomorphism $h_r$ such that $h_r(r) \in C$ and $cost(h_r) \leq cost(h)$. 
The following Algorithm~\ref{alg:naive-replacements:check} (CheckReplacement) implements this process.

\begin{algorithm}[H]
\caption{CheckReplacement}\label{alg:naive-replacements:check}
\footnotesize
\begin{minted}[xleftmargin=\parindent,linenos,escapeinside=||,mathescape=true]{python}
def CheckReplacement(c_0, C, maxLevel=3):
    T = CreateTreeForLevel(maxLevel)
    for conf in product(list(range(0,16)), repeat = pow(2, maxLevel)):
        minimalc_0Cost = MinCostWithRoots(T, conf, c_0)
        if(minimalc_0Cost == |$\infty$|):
           continue  
        if(minimalc_0Cost < MinCostWithRoots(T, conf, C)):
            return False 
    return True

def MinCostWithRoots(T, conf, possibleRoots):
    if len(conf) == 1:
        if(conf[0] in possibleRoots):
            return 0
        else:
            return |$\infty$|
    mincost = |$\infty$|
    for confp in ParentsConfigurations(T, conf):
        pcost = MinCostWithRoots(T, confp, possibleRoots)
        mincost = min(mincost, pcost)
    return mincost + sum([i for c in conf if c in |$B_1$|])
\end{minted}
\end{algorithm}

\subsection{Similar and solvable configurations}\label{sec:similar-and-solvable}
% TODO:
% X SIMiLAR x na formula
% X Substitution ao inves de substitute
% definir $conf {x \to c}$
% No lugar de substitute, Dada uma cor c, a gente escreve $conf {x \to c}$ para a configuração obtida de conf colorindo x com c.
% Usar custos no paragrafo seguinte
% if...define errado, tem que ser suppose...define
% Subs(conf)
% nao precisa dizer que é feasible
% elementary substitutions -> uma substituição elementar 
%======
In what follows, 
suppose $conf$ is a configuration of a tree $T$,
then $conf_{x \to c}$ is the configuration $conf^*$
such that $conf^*(x)=c$ and $conf^*(y) = conf(y)$ for every $y \in L(T) \setminus \{x\}$ where $x \in L(T)$.

Let $T$ be cubic tree,
we say that two configurations \(conf_1\) and \(conf_2\) of \(T\)
are \emph{similar} if \(conf_1(x) \neq conf_2(x)\)
for precisely one \(x\in L(T)\), 
i.e., \(|\{y\in L(T) : conf_1(y) \neq conf_2(y)\}| = 1\).
Equivalently, we say that \(conf_2\) is \emph{$x$-similar} to \(conf_1\).

Moreover,
let
$T$ be cubic tree,
$x$ a vertex such that $x \in L(T)$,
$T_{b}$ a complete binary tree of size $\ell$ such that $T \cap T_{b} = \{x\}$,
$conf$ a configuration of $T$
and 
$R$ be a replacement $(conf(x), C)$ in respect to $T_b$,
then $conf^*$ is \emph{$(x,R)$-similar to $conf$} if $conf^* \in \{conf_{x \to c} | c \in C \}$. 
Note that every configuration $(x,R)$-similar to $conf$ is also $x$-similar to $conf$.
We say that a configuration $conf*$ is a substitution for $conf$ if it is $(x, R)$-similar to $conf$ and $RC(conf^*) \leq RC(conf)$ 
for some fixed $x$ and $R$.
Additionally,
we say that $conf$ is \emph{solvable} for $\ell$
if
$conf$ is bad
and
there is $R=(conf(x), C)$ a replacement in respect to $T_{b}$,
such that for every $c \in C$, the configuration $conf_{x \to c}$ is a substitution and is good or solvable.
In what follows we fix $\ell_b > 0$ such that every replacement is 
in respect to a complete binary tree of size $\ell_b$
and recall that, by Lemma~\ref{lemma:replacements-monotonicity}, for this
it is enough to show that a replacement is in respect to any complete binary tree of size smaller then $\ell_b$.
With this, we say that a configuration is solvable if it is solvable for the fixed $\ell_b$.
Now, we call each pair $(x, R)$ that makes $conf$ solvable the \emph{solvability parameters} of $conf$.

Moreover,
the \emph{solvability complexity} of $conf$, 
denoted by $sc(conf)$, is defined to be 
0 if $conf$ is good, 
$\infty$ if bad and not solvable 
and, if $conf$ is solvable, $k+1$ where $k = min(\{k(x, R) | \text{ for each solvability parameters } (x, R)\})$,
and $k(x, R)$ is the maximum solvability complexity of every $(x, R)$-similar configuration to $conf$.

Therefore a configuration is solvable if and only if its solvability complex is finite and bigger then zero.

Algorithm~\ref{alg:naive-replacements} (GetCurrentLevelSubstitutions) 
tries to improve bad configurations by checking if they are a solvable.
For each bad configuration $conf$, it traverses leaf vertices and, for each one $x$, 
finds every $x$-similar configuration which is good or solvable and doesn't increase the restricted cost.
We call a \emph{replacement candidate} the pair formed by $conf(x)$ and the set $C_{cand}$ of these $x$-similar configurations.
Later, it checks if one of the replacement candidates is a replacement and, therefore, $conf$ is solvable.

\begin{algorithm}[H]
\caption{GetCurrentLevelSubstitutions}\label{alg:naive-replacements}
\footnotesize
\begin{minted}[xleftmargin=\parindent,linenos,escapeinside=||,mathescape=true]{python}
def GetCurrentLevelSubstitutions(T, bads, knownSolvable):
    replacementsCandidates = []
    for bad in bads: 
        fc, rc  = CalculateCosts(T, bad)
        for i in range(len(bad)):
            color = bad[i]
            siblingColor = GetSiblingColor(bad, i) 
            newColorsToTest = CH.vertices() - CH.neighbors(siblingColor) - [color] - |$B_1$|
            C = []
            for newColorToTest in newColorsToTest:
                bad[i] = newColorToTest
                #the similar configuration free and restricted costs
                sfc, src  = CalculateCosts(T, bad)
                #cannot be a substitution
                if(src > rc):
                    continue
                # is bad and not know to be solvable
                if(bad not in knownSolvable and sfc == |$\infty$| or sfc == src):
                    continue 
                C.append(newColorToTest)
            bad[i] = color
            if(len(C) != 0):
                replacementsCandidates.append((bad, i, C))
    solvableBads = set()
    for (bad, i, C) in replacementsCandidates: 
        if(CheckReplacement(bad[i], C)):
            solvableBads.add(bad)
    unsolvableBads = bads - solvableBads
    return solvableBads, unsolvableBads
\end{minted}
\end{algorithm}
The next lemma generalizes Lemma~\ref{lemma:every-good-configuration}.


%TODO girth on G previous lemmas
\begin{lemma}\label{lemma:every-good-and-solvable-configuration}
Let \(G\) be a graph with girth $g$,
$T \subset G$ a complete cubic tree rooted in $r$ of size $\ell$,
$h \colon G \to \ch$ be a homomorphism with $cost(h(r))>0$ 
and $\ell_b > 0$ a fixed integer such that $\ell + \ell_b < g$.
If $conf = h|_{L(T)}$ is good or solvable for $\ell_b$, 
then \(T\) can be extended to a tree \(T^+ \subseteq G\) of size $\ell + \ell_b$
for which there is a
$h$-compatible homomorphism $h'\colon T^+ \to \ch$ such that 
 \(cost(h') < cost(h|_{T^+})\) and, moreover, $cost(h'(r))=0$.
\end{lemma}

\begin{proof}
If $conf$ is good, just let $T^+ = T$ and we know it is true by Lemma~\ref{lemma:every-good-configuration}.
On the remaining case that $conf$ is solvable, we know that $sc(conf) = n$ where n is finite and bigger than zero for the fixed $\ell_b$.
We will prove on induction on $sc(conf)$.

On the base case, $sc(conf) = 1$,
therefore there is a vertex $x \in L(T)$ and replacement $R(conf(x), C)$ in respect to a complete binary tree of height $\ell_b$
such that, for every $c \in C$, $conf_{x \to c}$ is good.
Therefore, 
let 
$T^+$ be the tree $T$ extended to the height $\ell + \ell_b$,
$T_{b}$ be the complete binary of size $\ell_b$ tree rooted in $x$ such that $T_{b} \subset T^+$ 
and $T_{b} \cap T = \{x\}$.
$R$ is a replacement in respect to $T_{b}$, therefore we know that exists a homomorphism $h_{T_{b}} \colon T_{b} \to \ch$ such that:
(i)~$h_{T_{b}}(x) \in C$; 
(ii)~$h_{T_{b}}(L(T_{b})) = h(L(T_{b}))$; and
(iii)~$cost(h_{T_{b}}) \leq cost(h|_{T_{b}})$.
Let $h_{T_{b}}(r)$ be, without loss of generality, $c \in C$, 
$h_f \in RH(conf_{x \to c})$ be a homomorphism such that $cost(h_f) = FC(conf_{x \to c })$ 
and $h'$ the homomorphism over $T^*$ defined as: 
\[ 
h'(v) = 
     \begin{cases}
        h_{T_{b}}(v) &\quad\text{if } v\in V(T_{b} \setminus \{x\})\\
        h_f(v) &\quad\text{if } v \in V(T)\\
        h(v) &\quad\text{if } v \in V(T^+ \setminus (T \cup T_{b})).
     \end{cases}
\]
It follows that $h'(v)$ is 
$h$-compatible homomorphism $h'\colon T^+ \to \ch$ such that 
 \(cost(h') < cost(h|_{T^+})\) and, moreover, $cost(h'(r))=0$.

Now, suppose $sc(conf) = n$ where $n > 1$ and we know that the proposition stands for every positive until $n$.
Then there is a vertex $x \in L(T)$ and replacement $R(conf(x), C)$ in respect to a complete binary tree of height $\ell_b$,
such that $max(\{ sc(conf_{x \to c}) | c \in C \}) = n-1$.
Without loss of generality, suppose that the homomorphism $h_{T_{b}}$ that exists as consequence of $R$ 
is such that $h_{T_{b}}(x) = c \ in C$ and $sc(conf_{x \to c}) = n-1$.
Let $h_f \in RC(conf_{x \to c})$ be a homomorphism such that $cost(h_f) = FC(conf_{x \to c })$ 
and $h'$ the homomorphism over $T^*$ defined as:
\[
h'(v) =
     \begin{cases}
        h_{T_{b}}(v) &\quad\text{if } v\in V(T_{b} \setminus \{x\})\\
        h_f(v) &\quad\text{if } v\in V(T)\\
        h(v) &\quad\text{if } v \in V(T^+ \setminus (T \cup T_{b})).
     \end{cases}
\]
Then let $h^*$ be the $(h, h')$-modified homomorphism, note that 
$h^*|_{L(T)} = conf_{x \to c}$ 
and $sc(conf_{x \to c}) = n-1$, 
therefore, by the induction hypothesis, there is a $h$-compatible homomorphism for which the condition holds.
\end{proof}

Now, we are able to introduce Algorithm~\ref{alg:naive-conjecture-holds} (\texttt{GenerateUnsolvableConfs}) 
which is able to verify if there no unsolvable bad configurations 
on given complete cubic tree by calling iteratively Algorithm~\ref{alg:naive-replacements} passing the new solvable configurations found on the previous step together with the previous already know solvable configurations.
The algorithm stops 
when there aren't any unsolvable bad configuration left, or
when no more solvable configurations are found, since, in this case, any new call to Algorithm~\ref{alg:naive-replacements} produces the same result.

By Lemma~\ref{lemma:every-good-and-solvable-configuration}, if we find a complete cubic tree of size $\ell$ such that Algorithm~\ref{alg:naive-conjecture-holds} (\texttt{GenerateUnsolvableConfs}) is unable to generate any unsolvable bad configuration, we computationally proof Conjecture~\ref{conj:main-conjecture}.

\begin{algorithm}[H]
\caption{GenerateUnsolvableConfs}\label{alg:naive-conjecture-holds}
\footnotesize
\begin{minted}[xleftmargin=\parindent,linenos, breaklines, escapeinside=||,mathescape=true]{python}
def GenerateUnsolvableConfs(T):
    unsolvedBads = GenerateBadConfs(T)
    knownSolvable = {}
    while(unsolvedBads > 0):
        newSolvableBads, newUnsolvedBads = GetCurrentLevelSubstitutions(T, unsolvedBads, knownSolvable)
        if(len(newUnsolvedBads) == len(unsolvedBads)):
            break
        unsolvedBads = newUnsolvedBads 
        knownSolvable.extend(newSolvableBads)
    return unsolvedBads
\end{minted}
\end{algorithm}


\section{Complexity and Conclusion}\label{sec:complexity-analysys}

In this chapter we introduced two algorithms and proved that certain outputs verify Conjecture~\ref{conj:main-conjecture}.
Unfortunately, both have clearly exponential behavior.
Thus, for completeness, we present a brief complexity analysis of the worst-case scenario for Algorithm~\ref{conj:main-conjecture} 
which is a generalization of Algorithm~\ref{alg:naive-bottom-up}.
This analysis also motivates the optimizations presented in the next chapter. 
The algorithm traverses all the $16 ^{|L(T)|}$ possible configurations of $T$.
For each such configuration, it calls CalculateCosts which calls it self recursively for each of its parents configurations. 
Each father can be colored with at most five colors (this happens when all children are colored with the same color), 
and hence the number of parents configurations is at most \(5^p\), 
where \(p\) is the number of parents (which vary corresponding to the level of the tree).
% It finds the parents configurations by seeing, for each sibling pair or triple on the root's children, which colors can color the leaf's parents such that it is adjacent to all colors of its children.
% In the binary case, we have 3 distinct possibilities: 5 colors if both siblings are colored the same(recall that \ch~is 5-regular), 2 if the siblings are colored withall non distinct non adjacent colors and 0 on the remaining case. 
% In the root case, all possibilities remain and there is also the case of only one color choice for the root. 
% Therefore CalculateCosts calls it self $O(5^{\frac{L(T)}{2}})$ times.
Therefore in the worst-case scenario, the number of steps performed is at most \[16^{|L(T)|}\cdot 5^{\frac{|L(T)|}{2}}\cdot 5^{\frac{|L(T)|}{4}} \cdot \cdots \cdot 1\leq \big(16 \cdot 5^{\frac{1}{2} + \frac{1}{4} + \cdots } \big)^{|L(T)|} \leq 80^{|L(T)|}.\]

\begin{comment}
We say that two configurations \(conf_1\) and \(conf_2\)
are \emph{similar} if \(conf_1(x) \neq conf_2(x)\)
for at most one \(x\in L(T)\), 
i.e., if \(|\{x\in L(T) : conf_1(x) \neq conf_2(x)\}| = 1\);
and that a bad configuration \(conf_1\) is \emph{solvable}
if there are
(i) a vertex \(x\in L(T)\); 
(ii) a complete binary tree $T^*$ with height at most 3, rooted in $x$, and with $V(T^*) \cap V(T) = \{x\}$; and 
(iii) a replacement \((c_0,C)\) with respect to \(T^*\)
such that 
(a) \(conf_1(x) = c_0\); and 
(b) for every \(c\in C\), the configuration obtained from \(conf_1\) by coloring \(x\) with \(c\) is a good configuration with restricted cost at most $RC(conf_1)$.
In this case, we say that \(conf_1\) is solvable through the replacement \((c_0,C)\) at \(x\).

% \begin{lemma}\label{lemma:every-bad-solvable-configuration}
%     Let \(G\)  be a graph, $T$ be a complete tree in $G$ with root \(r\), 
%     and $h \colon G \to H$ be a homomorphism with $cost(h(r))>0$, 
%     for which \(conf = h|_{L(T)}\) is bad.
%     If $conf$ is solvable, 
%     then there is a tree \(T^+ \supset T\) and an $h$-compatible homomorphism $h'\colon T^+ \to H$ such that $cost(h') < cost(h_{|T^+} )$.
% \end{lemma}

% \begin{proof}
%     Let \(G\), \(T\), \(r\), \(h\), and \(conf\) as in the statement.
%     Suppose that \(conf\) is solvable by a replacement \((c_0,C)\) at the vertex \(x\in L(T)\), and let \(T^*\) be the witness of \((c_0,C)\).
    
% \end{proof}

% \begin{lemma}\label{lemma:every-bad-solvable-configuration}
%     Let \(G\)  be a graph, $T$ be a complete tree in $G$ with root \(r\), 
%     and $h \colon G \to H$ be a homomorphism with $cost(h(r))>0$, 
%     for which \(conf = h|_{L(T)}\) is bad.
%     Suppose that $conf$ is solvable by a replacement at a vertex \(x\) that is witnessed by a tree \(T^*\), 
%     and let \(T^+\subseteq G\) the minimal tree rooted at \(r\) that contains \(T\)
%     and whose subtree rooted at \(x\) is a copy of \(T^*\).
%     Then there is an $h$-compatible homomorphism $h'\colon T^+ \to H$ such that $cost(h') < cost(h_{|T^+} )$.
% \end{lemma}

\begin{lemma}
    Let \(G\)  be a graph, $T \subseteq G$ a complete cubic tree rooted in $r$, 
    and $h \colon G \to CH$ be a homomorphism with $cost(h(r))>0$. 
    If $conf = h|_{L(T)}$ is good or solvable, 
    then \(T\) can be extended to a tree \(T^+ \subseteq G\)
    for which there is $h$-compatible homomorphism $h'\colon T^+ \to CH$ such that 
     \(cost(h') < cost(h|_{T^+})\) and, moreover, $cost(h'(r))=0$.
    % then there are a tree \(T^+\), with \(T\subset T^+\), 
    % and an $h$-compatible homomorphism $h'\colon T^+ \to H$ such that 
    % \(cost(h') < cost(h|_{T^+})\) and, moreover, $cost(h'(r))=0$.
\end{lemma}
\begin{proof}
    If $conf$ is a good configuration, by Lemma \ref{lemma:every-good-configuration}, we have an $h$-compatible homomorphism $h'\colon T \to CH$ such that the $cost(h') < cost(h_|{T})$. 
    In this case, we set \(T^+ = T\), and the statement follows.
    
    Thus, we may assume that $conf$ is solvable.
    Then there is an \(x\in L(T)\), a tree $T^*$, and a replacement $(c_0,C)$ with respect to \(T^*\)
    satisfying (a) and (b) above. 
    %Let $T^*$ be the subtree of $T^+$ rooted in $x$, we know
    By the definition of replacement, there is an $(x,h|_{T^*})$-associated homomorphism $h^{*}$ for which $h^{*}(x) \in C$.
    Now, let $conf^*$ be the configuration obtained from \(conf\) by coloring \(x\) with $h^{*}(x)$.
    Thus, there is \(h_2 \in RH(conf_2)\) such that \(cost(h_2) = FC(conf_2)\).
    By the definition of solvable, \(conf^*\) is good and $RC(conf^*) \leq RC(conf)$. 
    Now, put \(T^+ = T \cup T^*\), 
    and let \(h'\) be the \(h\)-compatible homomorphism (with respect to \(T^+\)) defined by 
    \[ 
     h'(v) = 
         \begin{cases}
           h_2(v) &\quad\text{if } v\in V(T)\\
           h^*(v) &\quad\text{if } v\in V(T^*)\\
         \end{cases}
    \]

    Since \(V(T^*) \cap V(T) = \{x\}\), we have
    \begin{align*}
        cost(h') & = cost(h_2) + cost (h^*) - cost(h'(x)); \text{ and} \\
        cost(h|_{T^+}) & = cost(h|_{T}) + cost (h|_{T^*}) - cost(h(x))
    \end{align*}

    We know that $cost (h^*) \leq cost(h|_{T^*})$ because $(c_0,C)$ is a replacement with respect to \(T^*\).
    Moreover, by the definition of \(h_2\) we have
    $cost(h_2) = FC(conf_2)$ and $cost(h_2(r)) = 0$.
    Also, since \(conf_2\) is good, we have \(FC(conf_2) < RC(conf)\), 
    and hence \(cost(h_2) < RC(conf) \leq cost(h|_T)\).
    Therefore
    \begin{align*}
        cost(h')    & =     cost(h_2)   + cost (h^*)        - cost(h'(x))\\
                    & <     RC(conf)    + cost(h|_{T^*})    - cost(h'(x)) \\
                    & \leq  cost(h|_T)  + cost(h|_{T^*})    - cost(h'(x)) \\
                    & =     cost(h|_{T^+})
    \end{align*}
    as desired.
%    
    % We build a new \(h\)-compatible homomorphism (with respect to \(T^+ \)).
    % Let $T^+ = T \cup T^*$, we know there is the $(h(x), h)$-associated homomorphism $ah \colon T^* \to H$ such that  $cost(ah) \leq cost (h|_{T^*})$.
 %   
    % we have the $(h,h')$-replaced homomorphism $ah \colon T^+ \to H$ with $cost(ah) =0$
 %       
    % and we have that we can form the $(h,h')$-replaced homomorphism $ah \colon T^+ \to H$ with $cost(ah(r)) =0$ . 
\end{proof}
\end{comment}

